{
  "test_cases":
    {
      "maximum cut distance matrix": "import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\ndef create_graph_from_distance_matrix(distance_matrix):\n    \"\"\"Create a graph from the distance matrix.\"\"\"\n    G = nx.Graph()\n    num_nodes = len(distance_matrix)\n    for i in range(num_nodes):\n        for j in range(i + 1, num_nodes):\n            if distance_matrix[i][j] > 0:  # Ignore zero weights (no connection)\n                G.add_edge(i, j, weight=distance_matrix[i][j])\n    return G\n\ndef max_cut_heuristic(G):\n    \"\"\"Solve the Max-Cut problem using a simple greedy heuristic.\"\"\"\n    # Initialize two sets\n    set1 = set()\n    set2 = set(G.nodes)\n\n    while set2:\n        node = set2.pop()\n        # Calculate the cut difference if the node is added to set1\n        cut_if_added_to_set1 = sum(G[u][v]['weight'] for u in set1 for v in [node] if G.has_edge(u, v))\n        cut_if_added_to_set2 = sum(G[u][v]['weight'] for u in set2 for v in [node] if G.has_edge(u, v))\n        \n        # Greedily assign the node to the set that maximizes the cut\n        if cut_if_added_to_set1 > cut_if_added_to_set2:\n            set1.add(node)\n        else:\n            set2.add(node)\n    \n    return set1, set(G.nodes) - set1\n\ndef calculate_cut_value(G, set1, set2):\n    \"\"\"Calculate the cut value for the given partition.\"\"\"\n    cut_value = 0\n    for u in set1:\n        for v in set2:\n            if G.has_edge(u, v):\n                cut_value += G[u][v]['weight']\n    return cut_value\n\n# Example usage\ndistance_matrix = np.array([\n    [0, 3, 8, 0],\n    [3, 0, 2, 7],\n    [8, 2, 0, 4],\n    [0, 7, 4, 0]\n])\n\n# Create the graph from the distance matrix\nG = create_graph_from_distance_matrix(distance_matrix)\n\n# Solve the Max-Cut problem\nset1, set2 = max_cut_heuristic(G)\n\n# Calculate the cut value\ncut_value = calculate_cut_value(G, set1, set2)\n\n# Output the result\nprint(f\"Set 1: {set1}\")\nprint(f\"Set 2: {set2}\")\nprint(f\"Max-Cut Value: {cut_value}\")\n\n# Optionally, visualize the graph with the cut\npos = nx.spring_layout(G)\nnx.draw(G, pos, with_labels=True, node_color=['red' if node in set1 else 'blue' for node in G.nodes], node_size=800, font_size=16)\nnx.draw_networkx_edges(G, pos, edgelist=[(u, v) for u in set1 for v in set2 if G.has_edge(u, v)], edge_color='green', width=3)\nplt.show()",
      "clique": "import itertools\nimport networkx as nx\n\ndef is_clique(graph, nodes):\n    \"\"\"\n    Check if the given set of nodes form a clique in the graph.\n    \"\"\"\n    for u, v in itertools.combinations(nodes, 2):\n        if not graph.has_edge(u, v):\n            return False\n    return True\n\ndef find_clique(graph, k):\n    \"\"\"\n    Find a clique of size k in the given graph using a brute-force approach.\n    \"\"\"\n    nodes = list(graph.nodes)\n    for subset in itertools.combinations(nodes, k):\n        if is_clique(graph, subset):\n            return subset\n    return None\n\n# Example usage\nif __name__ == \"__main__\":\n    # Create a sample graph\n    G = nx.Graph()\n    edges = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4)]\n    G.add_edges_from(edges)\n    \n    k = 3  # Size of the clique to find\n    clique = find_clique(G, k)\n    \n    if clique:\n        print(f\"Clique of size {k} found: {clique}\")\n    else:\n        print(f\"No clique of size {k} found.\")",
      "maximum cut": "import networkx as nx\nfrom itertools import combinations\n\n# Brute-force Max-Cut solver\n\ndef maxcut_bruteforce(G):\n    max_cut_value = 0\n    best_partition = None\n\n    nodes = list(G.nodes())\n    for i in range(1, len(nodes)):\n        for cut in combinations(nodes, i):\n            partition_A = set(cut)\n            partition_B = set(nodes) - partition_A\n            cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n\n            if cut_value > max_cut_value:\n                max_cut_value = cut_value\n                best_partition = (partition_A, partition_B)\n\n    return max_cut_value, best_partition\n\n# Example usage\nif __name__ == \"__main__\":\n    G = nx.Graph()\n    G.add_edges_from([(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4), (4, 5), (5, 0)])\n\n    max_cut, partition = maxcut_bruteforce(G)\n    print(f\"Maximum cut value: {max_cut}\")\n    print(f\"Best partition: {partition}\")",
      "tsp": "import itertools\n\ndef calculate_distance(route, distance_matrix):\n    \"\"\"Calculate the total distance of a given route based on the distance matrix.\"\"\"\n    total_distance = 0\n    for i in range(len(route) - 1):\n        total_distance += distance_matrix[route[i]][route[i + 1]]\n    total_distance += distance_matrix[route[-1]][route[0]]  # Return to the starting city\n    return total_distance\n\ndef tsp_brute_force(distance_matrix):\n    \"\"\"Solve the TSP using a brute-force approach.\"\"\"\n    n = len(distance_matrix)\n    cities = list(range(n))\n    min_distance = float('inf')\n    best_route = None\n    \n    # Generate all possible routes (permutations of cities)\n    for route in itertools.permutations(cities):\n        current_distance = calculate_distance(route, distance_matrix)\n        if current_distance < min_distance:\n            min_distance = current_distance\n            best_route = route\n    \n    return best_route, min_distance\n\n# Example usage:\ndistance_matrix = [\n    [0, 10, 15, 20],\n    [10, 0, 35, 25],\n    [15, 35, 0, 30],\n    [20, 25, 30, 0]\n]\n\nbest_route, min_distance = tsp_brute_force(distance_matrix)\nprint(\"Best Route:\", best_route)\nprint(\"Minimum Distance:\", min_distance)",
      "independent set": "import itertools\n\ndef is_independent_set(graph, subset):\n    # Check if the subset is an independent set\n    for i in range(len(subset)):\n        for j in range(i + 1, len(subset)):\n            if graph[subset[i]][subset[j]] == 1:\n                return False\n    return True\n\ndef find_max_independent_set(graph):\n    n = len(graph)\n    nodes = list(range(n))\n    max_independent_set = []\n\n    # Check all possible subsets\n    for size in range(1, n + 1):\n        for subset in itertools.combinations(nodes, size):\n            if is_independent_set(graph, subset):\n                if len(subset) > len(max_independent_set):\n                    max_independent_set = subset\n\n    return max_independent_set\n\n# Example usage:\n# Adjacency matrix representation of the graph\ngraph = [\n    [0, 1, 0, 0, 0],\n    [1, 0, 1, 1, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 1],\n    [0, 0, 1, 1, 0]\n]\n\nmax_independent_set = find_max_independent_set(graph)\nprint(\"Maximum Independent Set:\", max_independent_set)",
      "eigenvalue": "import numpy as np\ndef minimum_eigenvalue(matrix):\n    eigenvalues = np.linalg.eigvals(matrix)\n    return np.min(eigenvalues)\nmatrix = np.array([[-2, 0, 0, -5], [0, 4, 1, 0], [0, 1, 4, 0], [-5, 0, 0, -2]])\nmin_eigval = minimum_eigenvalue(matrix)\nprint(f\"The minimum eigenvalue of the matrix is: {min_eigval}\")",
      "svm": "import numpy as np\nfrom sklearn import datasets\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.svm import SVC\nfrom sklearn.metrics import accuracy_score\n\n# Load the dataset\niris = datasets.load_iris()\nX = iris.data\ny = iris.target\n\n# Only take the first two features for simplicity\nX = X[:, :2]\n\n# Split the dataset into training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n\n# Standardize features by removing the mean and scaling to unit variance\nscaler = StandardScaler()\nX_train = scaler.fit_transform(X_train)\nX_test = scaler.transform(X_test)\n\n# Create an SVM classifier with an RBF kernel\nsvm_rbf = SVC(kernel='rbf', gamma='scale')\n\n# Train the classifier\nsvm_rbf.fit(X_train, y_train)\n\n# Make predictions\ny_pred = svm_rbf.predict(X_test)\n\n# Calculate accuracy\naccuracy = accuracy_score(y_test, y_pred)",
      "cnf": "def is_satisfiable(cnf_formula, assignment):\n    for clause in cnf_formula:\n        satisfied = False\n        for literal in clause:\n            var = abs(literal)\n            if (literal > 0 and assignment[var]) or (literal < 0 and not assignment[var]):\n                satisfied = True\n                break\n        if not satisfied:\n            return False\n    return True\n\ndef solve_cnf(cnf_formula, num_vars, assignment=None, var=1):\n    if assignment is None:\n        assignment = [None] * (num_vars + 1)\n\n    if var > num_vars:\n        if is_satisfiable(cnf_formula, assignment):\n            return assignment\n        return None\n\n    assignment[var] = True\n    result = solve_cnf(cnf_formula, num_vars, assignment, var + 1)\n    if result:\n        return result\n        \n    assignment[var] = False\n    result = solve_cnf(cnf_formula, num_vars, assignment, var + 1)\n    if result:\n        return result\n\n    return None\n\n# Example usage\nif __name__ == \"__main__\":\n    cnf_formula = [\n        [-1, -2, -3],\n        [1, -2, 3],\n        [1, 2, -3],\n        [1, -2, -3],\n        [-1, 2, 3],\n    ]\n\n    num_vars = 3  # Number of variables in the formula\n\n    result = solve_cnf(cnf_formula, num_vars)\n    if result:\n        print(\"Satisfiable assignment found:\")\n        for i in range(1, num_vars + 1):\n            print(f\"x{i} = {result[i]}\")\n    else:\n        print(\"No satisfiable assignment exists.\")",
      "addition": "left = 4\nright = 5\nsum = addition(left, right)\nprint(sum)",
      "multiplication": "# Define the multiplication function\ndef multiplication(left, right):\n    return left * right\n\n# Initialize variables\nleft = 4\nright = 5\n\n# Call the multiplication function and store the result\nproduct = multiplication(left, right)\n\n# Print the result\nprint(product)",
      "subtraction": "# Define the subtraction function\ndef subtraction(left, right):\n    return left - right\n\n# Initialize variables\nleft = 9\nright = 5\n\n# Call the subtraction function and store the result\ndifference = subtraction(left, right)\n\n# Print the result\nprint(difference)",
      "triangle finding": "import networkx as nx\nimport itertools\n\ndef find_triangles(G):\n    triangles = []\n    nodes = list(G.nodes)\n\n    # Iterate through all combinations of 3 nodes\n    for u, v, w in itertools.combinations(nodes, 3):\n        # Check if these nodes form a triangle\n        if G.has_edge(u, v) and G.has_edge(v, w) and G.has_edge(w, u):\n            triangles.append((u, v, w))\n    \n    return triangles\n\n# Example usage\nG = nx.Graph()\n\n# Add edges to the graph (example graph)\nG.add_edges_from([\n    (0, 1), (1, 2), (2, 0),  # Triangle between nodes 0, 1, 2\n    (0, 3), (3, 4),          # No triangle here\n    (1, 4), (2, 3),          # Additional connections\n])\n\n# Find all triangles in the graph\ntriangles = find_triangles(G)\n\nprint(\"Triangles found in the graph:\")\nfor triangle in triangles:\n    print(triangle)\n\n# Plot the graph and highlight triangles\ndef plot_graph_with_triangles(G, triangles):\n    pos = nx.spring_layout(G)\n    nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=800, font_size=15, font_color='black', edge_color='gray')\n    \n    # Highlight the triangles\n    for triangle in triangles:\n        nx.draw_networkx_edges(G, pos, edgelist=[(triangle[0], triangle[1]), (triangle[1], triangle[2]), (triangle[2], triangle[0])],\n                               width=8, alpha=0.5, edge_color='green')\n\n    plt.title(\"Triangles in the Graph\")\n    plt.show()\n\n# Plot the graph with triangles highlighted\nplot_graph_with_triangles(G, triangles)",
      "vrp": "import networkx as nx\nfrom ortools.constraint_solver import pywrapcp, routing_enums_pb2\n\ndef create_data_model(G, depot):\n    data = {}\n    data['graph'] = G\n    data['depot'] = depot\n    data['num_vehicles'] = 2  # Adjust the number of vehicles\n    data['locations'] = list(G.nodes)\n    data['num_locations'] = len(data['locations'])\n\n    # Create a distance matrix from the graph\n    distance_matrix = nx.floyd_warshall_numpy(G, weight='weight')\n    data['distance_matrix'] = distance_matrix.tolist()\n    \n    return data\n\ndef solve_vrp(data):\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(len(data['distance_matrix']),\n                                           data['num_vehicles'], data['depot'])\n    \n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n    \n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data['distance_matrix'][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add distance constraint.\n    dimension_name = 'Distance'\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        3000,  # vehicle maximum travel distance (adjust as needed)\n        True,  # start cumul to zero\n        dimension_name)\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n\n    # Set search parameters\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)\n\n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n    \n    if solution:\n        print_solution(manager, routing, solution)\n    else:\n        print(\"No solution found!\")\n\ndef print_solution(manager, routing, solution):\n    total_distance = 0\n    for vehicle_id in range(manager.GetNumberOfVehicles()):\n        index = routing.Start(vehicle_id)\n        plan_output = f'Route for vehicle {vehicle_id}:\\n'\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f' {manager.IndexToNode(index)} ->'\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(previous_index, index, vehicle_id)\n        plan_output += f' {manager.IndexToNode(index)}\\n'\n        plan_output += f'Distance of the route: {route_distance}m\\n'\n        print(plan_output)\n        total_distance += route_distance\n    print(f'Total distance of all routes: {total_distance}m')\n\n# Create a sample graph\nG = nx.Graph()\n\n# Add weighted edges between nodes (representing distances or costs)\nedges = [\n    (0, 1, 10), (0, 2, 20), (0, 3, 30), (0, 4, 40),\n    (1, 2, 25), (1, 3, 35), (1, 4, 45),\n    (2, 3, 15), (2, 4, 30),\n    (3, 4, 20)\n]\nG.add_weighted_edges_from(edges)\n\n# Define depot (starting point for all vehicles)\ndepot = 0\n\n# Create the data model\ndata = create_data_model(G, depot)\n\n# Solve the VRP\nsolve_vrp(data)",
      "coloring": "import networkx as nx\nimport matplotlib.pyplot as plt\n\n\ndef greedy_graph_coloring(G):\n    \"\"\"\n    Solve the graph coloring problem using a greedy algorithm.\n\n    Parameters:\n    - G (networkx.Graph): The graph to be colored.\n\n    Returns:\n    - dict: A dictionary mapping nodes to colors.\n    \"\"\"\n    color_assignment = {}\n    for node in G.nodes():\n        available_colors = set(range(len(G.nodes())))\n\n        # Exclude colors of adjacent nodes\n        for neighbor in G.neighbors(node):\n            if neighbor in color_assignment:\n                available_colors.discard(color_assignment[neighbor])\n\n        # Assign the smallest available color\n        color_assignment[node] = min(available_colors)\n\n    return color_assignment\n\n\ndef plot_colored_graph(G, color_assignment):\n    \"\"\"\n    Plot the graph with the colors assigned to each node.\n\n    Parameters:\n    - G (networkx.Graph): The graph to be plotted.\n    - color_assignment (dict): A dictionary mapping nodes to colors.\n    \"\"\"\n    pos = nx.spring_layout(G)\n    node_colors = [color_assignment[node] for node in G.nodes()]\n    nx.draw(G, pos, with_labels=True, node_color=node_colors, cmap=plt.cm.rainbow, node_size=500, font_weight='bold')\n    plt.show()\n\n\n# Example usage\n# Create a sample graph\nG = nx.Graph(6)  # Cycle graph with 6 nodes\nG.add_edges_from([(0, 1), (0, 2), (1, 2), (2, 3), (3, 4)])  # Adding more edges to make the graph more complex\n\n# Solve the coloring problem\ncolor_assignment = greedy_graph_coloring(G)\nprint(\"Color assignment:\", color_assignment)\n\n# Plot the result\nplot_colored_graph(G, color_assignment)",
      "factor" : "def factorize(n):\n    \"\"\"Return the prime factors of the given integer n.\"\"\"\n    factors = []\n    # Divide out factors of 2 first\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    # Divide out odd factors from 3 upwards\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n    # If remaining n is a prime number greater than 2\n    if n > 2:\n        factors.append(n)\n    return factors\n\n# Example usage:\nn = 35\nprint(f\"The prime factors of {n} are: {factorize(n)}\")"
    }

}