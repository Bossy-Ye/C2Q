{
  "test_cases":
    {
      "clique": "import itertools\nimport networkx as nx\n\ndef is_clique(graph, nodes):\n    \"\"\"\n    Check if the given set of nodes form a clique in the graph.\n    \"\"\"\n    for u, v in itertools.combinations(nodes, 2):\n        if not graph.has_edge(u, v):\n            return False\n    return True\n\ndef find_clique(graph, k):\n    \"\"\"\n    Find a clique of size k in the given graph using a brute-force approach.\n    \"\"\"\n    nodes = list(graph.nodes)\n    for subset in itertools.combinations(nodes, k):\n        if is_clique(graph, subset):\n            return subset\n    return None\n\n# Example usage\nif __name__ == \"__main__\":\n    # Create a sample graph\n    G = nx.Graph()\n    edges = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4)]\n    G.add_edges_from(edges)\n    \n    k = 3  # Size of the clique to find\n    clique = find_clique(G, k)\n    \n    if clique:\n        print(f\"Clique of size {k} found: {clique}\")\n    else:\n        print(f\"No clique of size {k} found.\")",
      "maximum cut": "import networkx as nx\nfrom itertools import combinations\n\n# Brute-force Max-Cut solver\n\ndef maxcut_bruteforce(G):\n    max_cut_value = 0\n    best_partition = None\n\n    nodes = list(G.nodes())\n    for i in range(1, len(nodes)):\n        for cut in combinations(nodes, i):\n            partition_A = set(cut)\n            partition_B = set(nodes) - partition_A\n            cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n\n            if cut_value > max_cut_value:\n                max_cut_value = cut_value\n                best_partition = (partition_A, partition_B)\n\n    return max_cut_value, best_partition\n\n# Example usage\nif __name__ == \"__main__\":\n    G = nx.Graph()\n    G.add_edges_from([(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4), (4, 5), (5, 0)])\n\n    max_cut, partition = maxcut_bruteforce(G)\n    print(f\"Maximum cut value: {max_cut}\")\n    print(f\"Best partition: {partition}\")",
      "tsp": "import itertools\n\ndef calculate_distance(route, distance_matrix):\n    \"\"\"Calculate the total distance of a given route based on the distance matrix.\"\"\"\n    total_distance = 0\n    for i in range(len(route) - 1):\n        total_distance += distance_matrix[route[i]][route[i + 1]]\n    total_distance += distance_matrix[route[-1]][route[0]]  # Return to the starting city\n    return total_distance\n\ndef tsp_brute_force(distance_matrix):\n    \"\"\"Solve the TSP using a brute-force approach.\"\"\"\n    n = len(distance_matrix)\n    cities = list(range(n))\n    min_distance = float('inf')\n    best_route = None\n    \n    # Generate all possible routes (permutations of cities)\n    for route in itertools.permutations(cities):\n        current_distance = calculate_distance(route, distance_matrix)\n        if current_distance < min_distance:\n            min_distance = current_distance\n            best_route = route\n    \n    return best_route, min_distance\n\n# Example usage:\ndistance_matrix = [\n    [0, 10, 15, 20],\n    [10, 0, 35, 25],\n    [15, 35, 0, 30],\n    [20, 25, 30, 0]\n]\n\nbest_route, min_distance = tsp_brute_force(distance_matrix)\nprint(\"Best Route:\", best_route)\nprint(\"Minimum Distance:\", min_distance)",
      "independent set": "import itertools\n\ndef is_independent_set(graph, subset):\n    # Check if the subset is an independent set\n    for i in range(len(subset)):\n        for j in range(i + 1, len(subset)):\n            if graph[subset[i]][subset[j]] == 1:\n                return False\n    return True\n\ndef find_max_independent_set(graph):\n    n = len(graph)\n    nodes = list(range(n))\n    max_independent_set = []\n\n    # Check all possible subsets\n    for size in range(1, n + 1):\n        for subset in itertools.combinations(nodes, size):\n            if is_independent_set(graph, subset):\n                if len(subset) > len(max_independent_set):\n                    max_independent_set = subset\n\n    return max_independent_set\n\n# Example usage:\n# Adjacency matrix representation of the graph\ngraph = [\n    [0, 1, 0, 0, 0],\n    [1, 0, 1, 1, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 1],\n    [0, 0, 1, 1, 0]\n]\n\nmax_independent_set = find_max_independent_set(graph)\nprint(\"Maximum Independent Set:\", max_independent_set)",
      "eigenvalue": "import numpy as np\ndef minimum_eigenvalue(matrix):\n    eigenvalues = np.linalg.eigvals(matrix)\n    return np.min(eigenvalues)\nmatrix = np.array([[-2, 0, 0, -5], [0, 4, 1, 0], [0, 1, 4, 0], [-5, 0, 0, -2]])\nmin_eigval = minimum_eigenvalue(matrix)\nprint(f\"The minimum eigenvalue of the matrix is: {min_eigval}\")",
      "svm": "import numpy as np\nfrom sklearn import datasets\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.svm import SVC\nfrom sklearn.metrics import accuracy_score\n\n# Load the dataset\niris = datasets.load_iris()\nX = iris.data\ny = iris.target\n\n# Only take the first two features for simplicity\nX = X[:, :2]\n\n# Split the dataset into training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n\n# Standardize features by removing the mean and scaling to unit variance\nscaler = StandardScaler()\nX_train = scaler.fit_transform(X_train)\nX_test = scaler.transform(X_test)\n\n# Create an SVM classifier with an RBF kernel\nsvm_rbf = SVC(kernel='rbf', gamma='scale')\n\n# Train the classifier\nsvm_rbf.fit(X_train, y_train)\n\n# Make predictions\ny_pred = svm_rbf.predict(X_test)\n\n# Calculate accuracy\naccuracy = accuracy_score(y_test, y_pred)",
      "cnf": "def is_satisfiable(cnf_formula, assignment):\n    for clause in cnf_formula:\n        satisfied = False\n        for literal in clause:\n            var = abs(literal)\n            if (literal > 0 and assignment[var]) or (literal < 0 and not assignment[var]):\n                satisfied = True\n                break\n        if not satisfied:\n            return False\n    return True\n\ndef solve_cnf(cnf_formula, num_vars, assignment=None, var=1):\n    if assignment is None:\n        assignment = [None] * (num_vars + 1)\n\n    if var > num_vars:\n        if is_satisfiable(cnf_formula, assignment):\n            return assignment\n        return None\n\n    assignment[var] = True\n    result = solve_cnf(cnf_formula, num_vars, assignment, var + 1)\n    if result:\n        return result\n        \n    assignment[var] = False\n    result = solve_cnf(cnf_formula, num_vars, assignment, var + 1)\n    if result:\n        return result\n\n    return None\n\n# Example usage\nif __name__ == \"__main__\":\n    cnf_formula = [\n        [-1, -2, -3],\n        [1, -2, 3],\n        [1, 2, -3],\n        [1, -2, -3],\n        [-1, 2, 3],\n    ]\n\n    num_vars = 3  # Number of variables in the formula\n\n    result = solve_cnf(cnf_formula, num_vars)\n    if result:\n        print(\"Satisfiable assignment found:\")\n        for i in range(1, num_vars + 1):\n            print(f\"x{i} = {result[i]}\")\n    else:\n        print(\"No satisfiable assignment exists.\")",
      "addition": "left = 4\nright = 5\nsum = addition(left, right)\nprint(sum)"
    }

}